// Generated by CoffeeScript 1.4.0
(function() {
  var Backbone, Channel, ChannelServer, helpers, io, lweb, shared, _;

  io = require('socket.io');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  _ = require('underscore');

  _.extend(exports, shared = require('./shared'));

  Channel = shared.SubscriptionMan2.extend4000({
    initialize: function() {
      this.name = this.get('name' || (function() {
        throw 'channel needs a name';
      })());
      return this.clients = {};
    },
    join: function(client) {
      var _this = this;
      this.clients[client.id] = client;
      return client.on('disconnect', function() {
        return _this.part(client);
      });
    },
    part: function(client) {
      console.log('part from', this.name, client.id);
      delete this.clients[client.id];
      if (_.isEmpty(this.clients)) {
        return this.del();
      }
    },
    broadcast: function(msg, exclude) {
      var _this = this;
      return _.map(this.clients, function(subscriber) {
        if (subscriber !== exclude) {
          return subscriber.emit(_this.name, msg);
        }
      });
    },
    del: function() {
      this.clients = {};
      return this.trigger('del');
    }
  });

  ChannelServer = shared.channelInterface.extend4000({
    initialize: function() {
      return this.channels = {};
    },
    broadcast: function(channelname, msg) {
      var channel;
      console.log('broadcast', channelname, msg);
      if (!(channel = this.channels[channelname])) {
        return;
      }
      return channel.broadcast(msg);
    },
    join: function(channelname, client) {
      var channel,
        _this = this;
      console.log('join to', channelname);
      if (!(channel = this.channels[channelname])) {
        channel = this.channels[channelname] = new Channel({
          name: channelname
        });
        channel.on('del', function() {
          return delete _this.channels[channelname];
        });
      }
      return channel.join(client);
    },
    part: function(channelname, socket) {
      var channel;
      if (!(channel = this.channels[channelname])) {
        return;
      }
      return channel.part(socket);
    }
  });

  lweb = exports.lweb = shared.SubscriptionMan2.extend4000(shared.queryClient, shared.queryServer, ChannelServer, {
    initialize: function() {
      var http, testyloopy,
        _this = this;
      http = this.get('http');
      if (!http) {
        throw "I need http instance in order to listen";
      }
      this.server = io.listen(http, {
        log: false
      });
      this.server.on('connection', function(client) {
        var host, id;
        id = client.id;
        host = client.handshake.address.address;
        console.log('got connection from', host, id);
        client.on('join', function(msg) {
          return _this.join(msg.channel, client);
        });
        client.on('part', function(msg) {
          return _this.part(msg.channel, client);
        });
        client.on('query', function(msg) {
          return _this.queryReceive(msg, client);
        });
        return client.on('reply', function(msg) {
          return _this.queryReplyReceive(msg, client);
        });
      });
      testyloopy = function() {
        _this.broadcast('testchannel', {
          ping: helpers.uuid()
        });
        return helpers.sleep(10000, testyloopy);
      };
      return testyloopy();
    }
  });

}).call(this);
