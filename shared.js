// Generated by CoffeeScript 1.7.1
(function() {
  var Backbone, Response, SubscriptionMan, channelInterface, helpers, queryClient, queryServer, v, validator, _;

  Backbone = require('backbone4000');

  _ = require('underscore');

  helpers = require('helpers');

  validator = require('validator2-extras');

  v = validator.v;

  SubscriptionMan = exports.SubscriptionMan = require('subscriptionman2');

  channelInterface = exports.channelInterface = Backbone.Model.extend4000({
    initialize: function() {
      return this.channels = {};
    },
    channel: function(channelname) {
      var channel;
      if (channel = this.channels[channelname]) {
        return channel;
      }
      channel = this.channels[channelname] = new this.ChannelClass({
        lweb: this,
        name: channelname
      });
      channel.once('del', (function(_this) {
        return function() {
          return delete _this.channels[channelname];
        };
      })(this));
      return channel;
    },
    channelsubscribe: function(channelname, pattern, callback) {
      var channel;
      channel = this.channel(channelname);
      if (!callback && pattern.constructor === Function) {
        callback = pattern;
        pattern = true;
      }
      return channel.subscribe(pattern, callback);
    },
    broadcast: function(channel, message) {
      return true;
    },
    join: function(channel, listener) {
      return true;
    },
    part: function(channel, listener) {
      return true;
    },
    del: function() {
      return true;
    }
  });

  Response = Backbone.Model.extend4000({
    constructor: function(id, client, parent) {
      this.id = id;
      this.client = client;
      this.parent = parent;
      this.verbose = this.parent.verbose;
      if (!client.responses) {
        client.responses = {};
      }
      return client.responses[this.id] = this;
    },
    write: function(payload) {
      if (this.ended) {
        console.warn('writing to ended query', payload);
        return;
      }
      if (!payload) {
        throw 'no payload';
      }
      if (this.verbose) {
        console.log("<", this.id, payload);
      }
      return this.client.emit('msg', {
        type: 'reply',
        id: this.id,
        payload: payload
      });
    },
    end: function(payload) {
      var msg;
      if (this.ended) {
        console.warn('ending ended query', payload);
        return;
      }
      if (this.verbose) {
        console.log("<<", this.id, payload);
      }
      this.ended = true;
      msg = {
        type: 'reply',
        id: this.id,
        end: true
      };
      if (payload) {
        msg.payload = payload;
      }
      this.client.emit('msg', msg);
      delete this.client.responses[this.id];
      return this.trigger('end');
    },
    cancel: function() {
      this.trigger('cancel');
      return this.end();
    }
  });

  queryClient = exports.queryClient = validator.ValidatedModel.extend4000({
    validator: {
      parent: 'Instance'
    },
    initialize: function() {
      this.callbacks = {};
      this.parent = this.get('parent');
      this.verbose = this.get('verbose') || this.parent.verbose || false;
      return this.parent.subscribe({
        type: 'reply',
        id: String
      }, (function(_this) {
        return function(msg) {
          var _base, _name;
          return typeof (_base = _this.callbacks)[_name = msg.id] === "function" ? _base[_name](msg.payload, msg.end || false) : void 0;
        };
      })(this));
    },
    query: function(payload, callback) {
      var id;
      console.log("QUERY", payload);
      if (!payload) {
        return console.warn('tried to send a message without payload');
      }
      this.parent.send({
        type: 'query',
        id: id = helpers.uuid(10),
        payload: payload
      });
      return this.callbacks[id] = callback;
    }
  });

  queryServer = exports.queryServer = validator.ValidatedModel.extend4000(SubscriptionMan.fancy, {
    validator: {
      parent: 'Instance'
    },
    initialize: function() {
      this.parent = this.get('parent');
      this.verbose = this.get('verbose') || this.parent.verbose || false;
      this.parent.subscribe({
        type: 'query',
        id: String,
        payload: true
      }, (function(_this) {
        return function(msg, realm, client) {
          var matches, response;
          if (_this.verbose) {
            console.log('>', msg.id, msg.payload);
          }
          response = new Response(msg.id, client, _this);
          matches = _this.event(msg.payload, response, realm);
          if (!matches) {
            return delete client.responses[msg.id];
          }
        };
      })(this));
      return this.parent.subscribe({
        type: 'queryCancel',
        id: String
      }, (function(_this) {
        return function(msg, realm, client) {
          var _ref;
          if (_this.verbose) {
            console.log('X', msg.id);
          }
          return (_ref = client.responses[msg.id]) != null ? _ref.cancel() : void 0;
        };
      })(this));
    },
    subscribe: function(pattern, callback) {
      if (!callback && pattern.constructor === Function) {
        callback = pattern && (pattern = true);
      }
      return SubscriptionMan.fancy.prototype.subscribe.call(this, pattern, callback);
    }
  });

}).call(this);
